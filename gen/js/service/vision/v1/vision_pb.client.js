// @generated by protobuf-ts 2.8.1 with parameter add_pb_suffix,generate_dependencies,force_optimize_code_size,long_type_string,output_javascript
// @generated from protobuf file "service/vision/v1/vision.proto" (package "viam.service.vision.v1", syntax proto3)
// tslint:disable
import { VisionService } from "./vision_pb";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
/**
 * VisionService declares the gRPC contract for a vision service
 *
 * @generated from protobuf service viam.service.vision.v1.VisionService
 */
export class VisionServiceClient {
    constructor(_transport) {
        this._transport = _transport;
        this.typeName = VisionService.typeName;
        this.methods = VisionService.methods;
        this.options = VisionService.options;
    }
    /**
     * GetModelParameterSchema takes the model name and returns the parameters needed to add one to the vision registry.
     *
     * @generated from protobuf rpc: GetModelParameterSchema(viam.service.vision.v1.GetModelParameterSchemaRequest) returns (viam.service.vision.v1.GetModelParameterSchemaResponse);
     */
    getModelParameterSchema(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * GetDetectorNames returns the list of detectors in the registry.
     *
     * @generated from protobuf rpc: GetDetectorNames(viam.service.vision.v1.GetDetectorNamesRequest) returns (viam.service.vision.v1.GetDetectorNamesResponse);
     */
    getDetectorNames(input, options) {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * AddDetector adds a new detector to the registry.
     *
     * @generated from protobuf rpc: AddDetector(viam.service.vision.v1.AddDetectorRequest) returns (viam.service.vision.v1.AddDetectorResponse);
     */
    addDetector(input, options) {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveDetector removes a detector from the registry.
     *
     * @generated from protobuf rpc: RemoveDetector(viam.service.vision.v1.RemoveDetectorRequest) returns (viam.service.vision.v1.RemoveDetectorResponse);
     */
    removeDetector(input, options) {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * GetDetectionsFromCamera will return a list of detections in the next image given a camera and a detector
     *
     * @generated from protobuf rpc: GetDetectionsFromCamera(viam.service.vision.v1.GetDetectionsFromCameraRequest) returns (viam.service.vision.v1.GetDetectionsFromCameraResponse);
     */
    getDetectionsFromCamera(input, options) {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * GetDetections will return a list of detections in the next image given the image bytes and a detector
     *
     * @generated from protobuf rpc: GetDetections(viam.service.vision.v1.GetDetectionsRequest) returns (viam.service.vision.v1.GetDetectionsResponse);
     */
    getDetections(input, options) {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    // Classification methods
    /**
     * GetClassifierNames returns the list of classifiers in the registry.
     *
     * @generated from protobuf rpc: GetClassifierNames(viam.service.vision.v1.GetClassifierNamesRequest) returns (viam.service.vision.v1.GetClassifierNamesResponse);
     */
    getClassifierNames(input, options) {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * AddClassifier adds a new classifier to the registry.
     *
     * @generated from protobuf rpc: AddClassifier(viam.service.vision.v1.AddClassifierRequest) returns (viam.service.vision.v1.AddClassifierResponse);
     */
    addClassifier(input, options) {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveClassifier adds a new classifier to the registry.
     *
     * @generated from protobuf rpc: RemoveClassifier(viam.service.vision.v1.RemoveClassifierRequest) returns (viam.service.vision.v1.RemoveClassifierResponse);
     */
    removeClassifier(input, options) {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * GetClassificationsFromCamera will return a list of classifications in the next image given a camera and a classifier
     *
     * @generated from protobuf rpc: GetClassificationsFromCamera(viam.service.vision.v1.GetClassificationsFromCameraRequest) returns (viam.service.vision.v1.GetClassificationsFromCameraResponse);
     */
    getClassificationsFromCamera(input, options) {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * GetClassifications will return a list of classifications in the next image given the image bytes and a classifier
     *
     * @generated from protobuf rpc: GetClassifications(viam.service.vision.v1.GetClassificationsRequest) returns (viam.service.vision.v1.GetClassificationsResponse);
     */
    getClassifications(input, options) {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    // Segmentation methods
    /**
     * GetSegmenterNames returns the list of segmenters in the registry.
     *
     * @generated from protobuf rpc: GetSegmenterNames(viam.service.vision.v1.GetSegmenterNamesRequest) returns (viam.service.vision.v1.GetSegmenterNamesResponse);
     */
    getSegmenterNames(input, options) {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * AddSegmenter adds a new segmenter to the registry.
     *
     * @generated from protobuf rpc: AddSegmenter(viam.service.vision.v1.AddSegmenterRequest) returns (viam.service.vision.v1.AddSegmenterResponse);
     */
    addSegmenter(input, options) {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveSegmenter removes a segmenter from the registry.
     *
     * @generated from protobuf rpc: RemoveSegmenter(viam.service.vision.v1.RemoveSegmenterRequest) returns (viam.service.vision.v1.RemoveSegmenterResponse);
     */
    removeSegmenter(input, options) {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * GetObjectPointClouds returns all the found objects in a pointcloud from a camera of the underlying robot,
     * as well as the 3-vector center of each of the found objects.
     * A specific MIME type can be requested but may not necessarily be the same one returned.
     *
     * @generated from protobuf rpc: GetObjectPointClouds(viam.service.vision.v1.GetObjectPointCloudsRequest) returns (viam.service.vision.v1.GetObjectPointCloudsResponse);
     */
    getObjectPointClouds(input, options) {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
}
